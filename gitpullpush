#!/usr/bin/env bash  
set -euo pipefail  
  
cd /etc/nixos  
  
branch="$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo main)"  
  
# Helper: recompute ahead/behind  
recalc_ahead_behind() {  
  local counts  
  counts=$(git rev-list --left-right --count "origin/$branch"...HEAD 2>/dev/null || echo "0 0")  
  behind=$(echo "$counts" | awk '{print $1}')  
  ahead=$(echo "$counts"  | awk '{print $2}')  
}  
  
# Helper: ask for commit message and commit  
commit_with_prompt() {  
  echo "You have uncommitted changes."  
  git status -sb  
  echo  
  
  read -rp "Commit message (leave empty to abort): " msg  
  if [ -z "$msg" ]; then  
    echo "Aborting: empty commit message."  
    return 1  
  fi  
  
  git add .  
  git commit -m "$msg"  
}  
  
# Helper: ask whether to push  
confirm_and_push() {  
  echo  
  read -rp "Push to origin/$branch? [y/N]: " ans  
  case "$ans" in  
    y|Y)  
      echo "Pushing to origin/$branchâ€¦"  
      git push origin "$branch"  
      ;;  
    *)  
      echo "Not pushing."  
      ;;  
  esac  
}  
  
echo "==> Syncing /etc/nixos ($branch)"  
  
# Make sure we know about remote state  
git fetch origin >/dev/null 2>&1 || true  
  
# Initial state  
dirty=false  
if git status --porcelain | grep -q .; then  
  dirty=true  
fi  
  
ahead=0  
behind=0  
recalc_ahead_behind  
  
echo "   dirty=$dirty ahead=$ahead behind=$behind"  
  
########################################  
# 1. Handle dirty + behind (must commit before pull)  
########################################  
if [ "$dirty" = true ] && [ "$behind" -gt 0 ]; then  
  echo  
  echo "You have uncommitted changes AND remote has new commits."  
  echo "Git cannot pull safely with a dirty working tree."  
  echo "We will commit your local changes first, then pull."  
  echo  
  
  commit_with_prompt || exit 1  
  dirty=false  
  
  # After committing, recompute ahead/behind  
  recalc_ahead_behind  
  echo "   After commit: dirty=$dirty ahead=$ahead behind=$behind"  
fi  
  
########################################  
# 2. Handle diverged (ahead + behind, clean)  
########################################  
if [ "$dirty" = false ] && [ "$ahead" -gt 0 ] && [ "$behind" -gt 0 ]; then  
  echo  
  echo "ðŸ¤¡  Well shit, you done fucked up: branch has diverged (ahead & behind)."  
  echo "    Attempting 'git pull --rebase origin $branch' to straighten this outâ€¦"  
  echo  
  
  git pull --rebase origin "$branch"  
  
  # After rebase, recompute ahead/behind  
  recalc_ahead_behind  
  echo "   After rebase: dirty=$dirty ahead=$ahead behind=$behind"  
fi  
  
########################################  
# 3. Handle dirty (only) â€“ commit, then optionally push  
########################################  
if [ "$dirty" = true ]; then  
  echo  
  echo "State: DIRTY (no remote changes)."  
  commit_with_prompt || exit 1  
  
  dirty=false  
  recalc_ahead_behind  
  echo "   After commit: dirty=$dirty ahead=$ahead behind=$behind"  
  
  if [ "$ahead" -gt 0 ]; then  
    confirm_and_push  
  fi  
  
  echo "==> Done."  
  exit 0  
fi  
  
########################################  
# 4. Handle behind only â€“ just pull  
########################################  
if [ "$behind" -gt 0 ] && [ "$ahead" -eq 0 ]; then  
  echo  
  echo "State: BEHIND (remote has $behind new commit(s))."  
  echo "Pulling with rebase from origin/$branchâ€¦"  
  git pull --rebase origin "$branch"  
  echo "==> Done."  
  exit 0  
fi  
  
########################################  
# 5. Handle ahead only â€“ offer to push  
########################################  
if [ "$ahead" -gt 0 ] && [ "$behind" -eq 0 ]; then  
  echo  
  echo "State: AHEAD (you have $ahead local commit(s) not pushed)."  
  confirm_and_push  
  echo "==> Done."  
  exit 0  
fi  
  
########################################  
# 6. Clean and in sync  
########################################  
echo  
echo "State: CLEAN and in sync with origin/$branch."  
echo "Nothing to do."  
exit 0  
 
